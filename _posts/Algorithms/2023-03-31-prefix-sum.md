---
title: "구간 합 이해하기"
excerpt: "구간 합(Prefix sum)에 대해 정리"

categories: algorithm
toc: true
toc_sticky: true
date: 2023-03-31
last_modified_at: 2023-03-31
---

### 구간 합(Prefix sum) 알고리즘

## 1차원에서의 작동방식

만약 0부터 5까지의 숫자가있는 배열 arr = [0, 1, 2, 3, 4, 5]에서 3 ~ 5 구간의 합을 알고싶다면 어떻게 해야할까?  
가장 쉽게 떠올릴수있는 방법은 아래와 같다

```python
arr = [0, 1, 2, 3, 4, 5]
start, end = 3, 5   # 구하고싶은 구간의 인덱스 범위
total = 0
for idx in range(start, end + 1):
    if idx >= len(arr):
        break
    total += arr[idx]
print(total)

```

이 코드는 구간합을 구할횟수가 적다면 문제가 없을수도 있다. 하지만 만약 1억번을 구해야한다면?  
코드의 시간복잡도 O(N) = O(end - start + 1) = 최악의경우 O(6)을 1억번곱해야하므로 O(6 \* 100,000,000) = O(600,000,000)이 나오고  
파이썬은 대략 1초에 2천만번의 연산이 가능하다고 하니 600,000,000 / 20,000,000 = 30초가 걸린다.

이것을 방지하기위한 알고리즘이 바로 구간 합(Prefix sum)이다.  
작동방식도 매우간단한데 0부터 n까지의 합을 기억해두고 구간 합이 필요할때 꺼내쓰면 된다.  
만약 위 예제에서 3부터 5까지의 구간 합을 구한다고 치면 미리계산해둔 0~5까지의 합에서 0~2까지의 합을 빼면 구할수있게된다.

```python
arr = [0, 1, 2, 3, 4, 5]
prefix_sum = [0]    # start가 0일때도 start-1 계산에 문제가 없도록 0을 미리 넣어줌
for idx, num in enumerate(arr):
    if idx == 0:
        prefix_sum.append(num)
    else:
        prefix_sum.append(num + prefix_sum[idx - 1])

start, end = 3, 5   # 구하고싶은 구간의 인덱스 범위
for _ in range(100000000): # 1억번 반복
    print(prefix_sum[end] - prefix_sum[start - 1])
```

이렇게 하면 구간합을 구할때 미리 구해둔 prefix_sum에서 값을 가져오기만 하면되서 시간복잡도가 O(N) => O(1)로 개선이 가능해진다.  
코드의 시간복잡도가 O(600,000,000)(30초)에서 O(100,000,000)(5초)로 줄어들었다. 줄어들긴했어도 5초나 걸리는건 파이썬의 느린속도때문이니 어쩔수가없다.  
같은논리의 코드를 c++와같은 속도가 빠른언어로 구현한다면 c++의 연산속도가 대략 1초에 1억연산을 하니 O(600,000,000)(6초) => O(100,000,000)(1초)가 된다.

## 2차원에서의 작동방식

작성중...
