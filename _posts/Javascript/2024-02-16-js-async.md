---
title: "[JavaScript] 자바스크립트의 비동기"
excerpt: "자바스크립트의 비동기에 대해 알아보자"

categories:
toc: true
toc_sticky: true
date: 2024-02-16
last_modified_at: 2024-02-16
---

### 자바스크립트는 싱글스레드

비동기 작업에 대해 알아보기전에 알아야 할 것이있습니다 그것은 바로 자바스크립트는 싱글스레드라는 것입니다.

싱글스레드는 라는 말이 어렵게 들릴수있지만 간단하게 말하자면 자바스크립트는 한번에 1개의 작업만 가능하다는것입니다 당연한 말처럼 들리지만 이것은 당연한것이 아닙니다.

예를들어 버튼에 이벤트를 추가한다고 했을때

```js
const button = someElement;

const clap = () => {
  console.log("Clap!");
};

button.addEventListener("click", clap);
```

이런식으로 코드를 작성했을것입니다 자바스크립트는 코드의 위쪽에서 아래로 내려가면서 코드를 차례대로 실행시키며 버튼에 이벤트를 추가합니다 이는 싱글스레드라서 1개의 작업만이 가능하므로 작업이 끝나기 전까지 다른 코드의 실행을 차단하기 때문입니다.

만약 멀티스레드라면 여러작업을 동시에 실행하므로 버튼이 할당되기전에 버튼에 이벤트를 추가해버려서 에러를 일으키는 일이 일어날수도 있습니다.

물론 멀티스레드를 지원하는 언어들도 그런일이 없도록 개발자들이 설계를 하지만(Ex. 파이썬의 GIL) 그런일이 일어날수도 있다는것을 알아두시길 바랍니다.

### 비동기작업

자바스크립트의 싱글스레드에는 치명적인 단점이 있습니다 1개의 작업만 가능하기때문에 1시간후에 할 작업을 예약을 시켜버리면 자바스크립트는 그 시간을 추적하느라 해당 코드 뒤에있는 작업들은 1시간을 기다린후에 실행시킬겁니다.

보기만 해도 정말 비효율적인 일입니다 그럼 그냥 해당작업을 나중에 해야할 숙제처럼 미뤄버리고 다음 코드들을 실행시키면 어떨까요? 여기서 나온 개념이 바로 비동기 작업입니다.

사실 위에있는 버튼에 클릭이벤트를 추가하는 것도 비동기 작업입니다 위의 코드는 버튼이 클릭될때 clap이라는 함수를 실행시키라는 것인데 이 버튼이 언제클릭될지는 아무도 모릅니다 어쩌면 평생 클릭되지 않을수도 있죠 동기작업이라면 버튼이 클릭될때까지 자바스크립트는 아무일도 하지않을것입니다 하지만 자바스크립트는 해당 이벤트리스너를 추가한다음 언제 실행할지는 브라우저에게 떠맡긴다음 다음 코드들을 실행합니다 만약 버튼에 클릭이 생기면 브라우저가 어떤 함수를 실행시켜야하는지 자바스크립트에게 알려주고 자바스크립트는 현재 하고있는 작업이 끝나면 해당 함수를 실행하는 것입니다.

비동기작업에 대해서는 어렵게 생각할필요 없이 실행하려면 오래 기다려야하는 작업들을 숙제처럼 미뤄버리고 다른작업들을 실행하는것이라고 보면 됩니다.

주의할점은 실행하면 완료까지 오래걸리는 작업이아니라 작업을 실행하기까지 오래 대기해야하는 작업을 미룬다는것입니다! 가령 for루프에서 숫자를 1억까지 세는 작업은 오래걸리는 작업이지 for루프를 실행하기 전에 1억초를 기다려야 하는 작업이 아니므로 비동기 작업이 아닙니다.

```js
// 이 작업은 실행이 오래걸리는 작업으로 비동기작업이 될수없음!
for (let i = 0; i <= 100000000; i++) {
  console.log(i);
}

// 이 작업은 for루프를 실행시키는데에 1억초를 기다려야하는 작업이므로 비동기 실행
setTimeout(() => {
  for (let i = 0; i <= 100000000; i++) {
    console.log(i);
  }
}, 100000000000);
```

### Event loop

자바스크립트가 브라우저에게 언제 작업해야하는지 알려달라고 떠맡기고 나면 브라우저는 어떻게 자바스크립트에게 해당 작업을 실행시키라고 알려줄수있을까요?

# Message queue

메세지 큐는 브라우저에만 있는 기능은 아닙니다 자바스크립트에서 브라우저에게 실행할때를 알려달라고 떠맡긴 작업(Ex. 버튼이 클릭되었을때)이 이제 작업할때가 되었을떄 브라우저는 해당 작업을 메세지큐에 등록합니다.

메세지큐에 등록된 작업은 바로 실행되는것이 아니라 이벤트 루프가 자바스크립트가 현재 작업중인지 확인하고 자바스크립트가 아무것도 하고있지 않을경우(콜스택이 비어있을경우) 메세지 큐에 등록된 작업들을 차례대로 자바스크립트 콜스택에 푸시합니다.

중요한점은 이벤트루프는 자바스크립트의 일부가 아니라 자바스크립트를 사용하고있는 호스트의 일부라는 것입니다.

### 사용법

# setTimeout

setTimeout()은 2개의 매개변수를 가지고 있습니다 첫번쨰 매개변수는 타이머가 끝난후 실행해야할 함수를 받습니다 이런 함수를 콜백함수(Callback function) 라고도 합니다.

두번째 매개변수는 타이머의 숫자를 밀리초(ms)단위로 받습니다. 100으로 설정하면 0.1초 후에 콜백함수를 메세지 큐에 등록합니다.

```js
// 0.1초 뒤에 익명함수를 메세지큐에 등록
setTimeout(() => {
  console.log("Execute!");
}, 100);
```

그런데 타이머를 0으로 설정했을때 재밌는일이 생깁니다.

```js
setTimeout(() => {
  console.log("Timer execute!");
}, 0);
console.log("Global execute");
```

이 코드의 결과는 어떻게 될까요? 타이머가 0ms로 설정되어있으니 콜백함수가 바로 실행되어 Timer execute!가 먼저 콘솔에 출력이 될까요?

```js
// 결과
// Global execute
// Timer execute!
```

예상했던것과 다르게 Global execute가 먼저 출력됩니다 왜 그런것일까요?

비동기 작업은 위에서 말한것과 같이 브라우저에 맡긴후에 다음 코드를 실행한다고 했습니다. 자바스크립트는 타이머가 0ms로 설정되어있어도 브라우저에 타이머를 넘깁니다 그럼 브라우저는 콜백함수를 바로 메세지 큐에 등록하고 이벤트루프는 console.log("Global execute")가 끝나야 콜스택이 비므로 그때서야 콜백함수를 콜스택에 푸시합니다.

### 콜백지옥

작성중...
