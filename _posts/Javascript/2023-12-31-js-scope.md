---
title: "Javascript 스코프와 렉시컬 스코프"
excerpt: "Javascript의 스코프에 대해 알아보자"

categories: javascript
toc: true
toc_sticky: true
date: 2023-12-31
last_modified_at: 2023-12-31
---

### 머릿말

스코프에 대한 개념은 잡혀있지만 렉시컬 스코프에 대해 제대로 이해하지 못한거 같아 스코프에 대해 공부한 내용을 정리

### 스코프들

스코프란 변수나 매개변수, 함수같은것들에 접근할수 있는 범위를 정의해둔것을 말합니다.

자바스크립트에는 함수 스코프와 블록 스코프가 있는데요 해당 스코프들은 말 그대로 함수의 단위별로 나뉘는 스코프, 중괄호{}(블록)별로 나뉘는 스코프를 말합니다.

이 스코프들은 자바스크립트의 변수 선언방식인 var과 let, const에 접근할수 있는 범위를 설명해줍니다.

말로만 들으면 잘 이해가 안갈수도 있으니 아래에 예시코드를 써보겠습니다.

### 함수 스코프

함수 스코프는 함수의 블록별로 스코프가 나뉘는데요 함수안에 있는 정보는 함수바깥에선 접근이 불가합니다.

var 변수 선언방식이 이 스코프를 사용합니다.

```js
// 전역 스코프
var a = 1;

function b() {
  // 블록 스코프
  var c = 2;
  console.log(a); // 1, 자신의 스코프에 해당 정보가 없을때 상위 스코프에서 해당 정보를 찾은다음 값을 가져올수 있습니다.
  console.log(c); // 2, c는 같은 함수의 블록안에 있으므로 변수 c의 정보를 가져올수있음
}

console.log(a); // 1, 같은 전역 스코프에서 a를 사용했으므로 변수 a의 정보를 가져옴
console.log(c); // Error!, 함수 b의 바깥에서 변수 c에대해 접근할수 없으므로 오류가 발생함
```

이 방식에는 크나큰 단점이있는데요 if문이나 for루프같이 별도의 블록내에 있는 정보들은 격리가 돼지않는다는 점입니다.

for문이나 if문 안에서만 사용하고 싶은 변수가 있을때 if문이나 for문의 코드가 다 끝나도 해당 변수는 사라지지않고 외부에서 해당 변수의 값을 가져올수있습니다.

```js
if (true) {
  var a = 1;
}

console.log(a); // if문이 끝난후에도 if문 안에있는 a변수가 사라지지않음
```

이 방식은 버그를 일으킬수있는 가능성을 가지고있는데 여기에 대한 해결책으로 나온것이 블록스코프와 let, const변수 선언 방식입니다.

### 블록 스코프

이 스코프는 중괄호{}를 기준으로 스코프가 나뉘는 방식입니다 if문과 for문과 같이 중괄호를 가지고 있는 코드에서 중괄호 내에서 변수를 선언하면 외부에서 중괄호 내에있는 정보에 접근이 불가합니다.

let과 const변수 선언 방식이 블록 스코프방식을 사용합니다.

```js
// 전역 스코프
const a = 1;

function b() {
  // 함수 스코프
  const c = 2;
  console.log(a); // 1, 상위 스코프에서 a에 대한 정보를 가져올수 있습니다.
  console.log(c); // 2, 같은 블록에 있으므로 c에 대한 정보를 가져올수 있습니다.
}

if (true) {
  // 블록 스코프
  const d = 3;
  console.log(d); // 3, 같은 블록에 있으므로 d에 접근이 가능합니다.
}

console.log(c); // ERROR!, 함수 스코프와 동일하게 함수 외부에서 함수 내부의 정보에 접근할수 없습니다.
console.log(d); // ERROR!, if문의 중괄호 블록 바깥에서 블록 내부에 있는 d에대해 접근이 불가합니다.
```

### 그럼 렉시컬 스코프는 뭐지?

렉시컬 스코프는 스코프의 위치를 정하는 방식인데요 변수나 함수가 호출되는곳에 따라서 스코프가 정해지는게 아닌 자신이 정의된곳에 따라 스코프가 결정되는 것을 말합니다.

이것 역시 말로만 해서는 무슨 뜻인지 잘 와닫지 않으니 예시 코드를 보여드리겠습니다.

```js
// 전역 스코프
var a = 1;

function b() {
  // 함수 b 스코프
  var a = 999;
  console.log(a); // 999, 가장 가까운 a인 같은 함수내에 있는 a의 값을 가져옵니다.
  c();
}

function c() {
  console.log(a);
  // 1, 함수 c를 함수 b에서 호출하였으므로 상위 스코프가 함수 b일것 같지만 함수 c를 정의했을때 이미 스코프가 결정되었으므로 상위 스코프는 함수 b의 스코프가 아닌 전역 스코프가 됩니다.
}

b();
```

함수 c는 함수 b안에서 호출되므로 함수 c가 함수 b의 하위 스코프가 될거 같지만 함수 c는 전역 스코프에 정의 되어있으므로 어디서 호출되던 상관없이 전역 스코프의 하위 스코프가 됩니다.

### 비동기 예시

```js
function varScope() {
  for (var index = 0; index < 3; index++) {
    setTimeout(() => {
      console.log(index);
    }, 100);
  }
}

function letScope() {
  for (let index = 0; index < 3; index++) {
    setTimeout(() => {
      console.log(index);
    }, 100);
  }
}

varScope(); // 3, 3, 3 출력
letScope(); // 0, 1, 2 출력
```

비동기나 setTimeout에 관해 알지못해도 상관없습니다 해당 코드는 for루프가 끝난후 setTimeout안에 있는 내용을 실행하는 내용입니다.

varScope에서 0, 1, 2가 출력될것이라는 예상과는 달리 3, 3, 3이 출력된다 그리고 또 신기한건 index를 var말고 let으로 변경하면 예상대로 0, 1, 2가 출력됩니다.

함수 스코프와 블록 스코프의 차이때문에 생기는 일인데 이해하기 쉽게 for문을 분해해보겠습니다.

```js
function varScope() {
  // 함수 스코프
  var index = 0;
  {
    setTimeout(() => {
      console.log(index);
    }, 100);
    index++; // 1
  }
  {
    setTimeout(() => {
      console.log(index);
    }, 100);
    index++; // 2
  }
  {
    setTimeout(() => {
      console.log(index);
    }, 100);
    index++; // 3
  }
}
```

for문을 분해하면 위의 코드와 비슷하다고 할수있습니다 var은 위에서 말했듯 스코프가 함수로만 나뉘므로 for문의 {}안에 있는 코드도 결국 다 같은 스코프에 있게됩니다.

for문이 끝나면 각 루프에서 참조하는 index가 독립적이지않고 같은 index를 참조하고 있으므로 3, 3, 3이 출력되는 것입니다 그럼 이제 let은 왜 0, 1, 2가 출력되는지 대충 감이잡히실겁니다.

```js
function letScope() {
  {
    // 블록 스코프
    let index = 0;
    setTimeout(() => {
      console.log(index);
    }, 100);
  }
  {
    // 블록 스코프
    let index = 1;
    setTimeout(() => {
      console.log(index);
    }, 100);
  }
  {
    // 블록 스코프
    let index = 2;
    setTimeout(() => {
      console.log(index);
    }, 100);
  }
}
```

let은 var과는 다르게 블록 스코프를 가지고있습니다 for문도 바디에 블록({})을 가지고있으므로 각 루프마다 스코프가 나뉘게 됩니다 for 루프가 끝난뒤 setTimeout안의 console.log에서 자신과 가장 가까운 스코프에서 index를 찾으므로 0, 1, 2가 출력되는 것입니다.

자신의 스코프에 없는 데이터를 상위 스코프에서 찾는건 스코프 체인 또는 Lexical Nesting Structure라고 하는데 이에 대해서는 추후에 포스팅하겠습니다.
