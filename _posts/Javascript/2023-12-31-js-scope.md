---
title: "Javascript 스코프와 렉시컬 스코프"
excerpt: "Javascript의 스코프에 대해 알아보자"

categories: javascript
toc: true
toc_sticky: true
date: 2023-12-31
last_modified_at: 2023-12-31
---

### 머릿말

스코프에 대한 개념은 잡혀있지만 렉시컬 스코프에 대해 제대로 이해하지 못한거 같아 스코프에 대해 공부한 내용을 정리

## 스코프들

스코프란 변수나 매개변수, 함수같은것들에 접근할수 있는 범위를 정의해둔것을 말합니다.

자바스크립트에는 함수 스코프와 블록 스코프가 있는데요 해당 스코프들은 말 그대로 함수의 단위별로 나뉘는 스코프, 중괄호{}(블록)별로 나뉘는 스코프를 말합니다.

이 스코프들은 자바스크립트의 변수 선언방식인 var과 let, const에 접근할수 있는 범위를 설명해줍니다.

말로만 들으면 잘 이해가 안갈수도 있으니 아래에 예시코드를 써보겠습니다.

# 함수 스코프

함수 스코프는 함수의 블록별로 스코프가 나뉘는데요 함수안에 있는 정보는 함수바깥에선 접근이 불가합니다.

var 변수 선언방식이 이 스코프를 사용합니다.

```js
// 전역 스코프
var a = 1;

function b() {
  // 블록 스코프
  var c = 2;
  console.log(a); // 1, 자신의 스코프에 해당 정보가 없을때 상위 스코프에서 해당 정보를 찾은다음 값을 가져올수 있습니다.
  console.log(c); // 2, c는 같은 함수의 블록안에 있으므로 변수 c의 정보를 가져올수있음
}

console.log(a); // 1, 같은 전역 스코프에서 a를 사용했으므로 변수 a의 정보를 가져옴
console.log(c); // Error!, 함수 b의 바깥에서 변수 c에대해 접근할수 없으므로 오류가 발생함
```

이 방식에는 크나큰 단점이있는데요 if문이나 for루프같이 별도의 블록내에 있는 정보들은 격리가 돼지않는다는 점입니다.

for문이나 if문 안에서만 사용하고 싶은 변수가 있을때 if문이나 for문의 코드가 다 끝나도 해당 변수는 사라지지않고 외부에서 해당 변수의 값을 가져올수있습니다.

```js
if (true) {
  var a = 1;
}

console.log(a); // if문이 끝난후에도 if문 안에있는 a변수가 사라지지않음
```

이 방식은 버그를 일으킬수있는 가능성을 가지고있는데 여기에 대한 해결책으로 나온것이 블록스코프와 let, const변수 선언 방식입니다.

# 블록 스코프

이 스코프는 중괄호{}를 기준으로 스코프가 나뉘는 방식입니다 if문과 for문과 같이 중괄호를 가지고 있는 코드에서 중괄호 내에서 변수를 선언하면 외부에서 중괄호 내에있는 정보에 접근이 불가합니다.

let과 const변수 선언 방식이 블록 스코프방식을 사용합니다.

```js
// 전역 스코프
const a = 1;

function b() {
  // 함수 스코프
  const c = 2;
  console.log(a); // 1, 상위 스코프에서 a에 대한 정보를 가져올수 있습니다.
  console.log(c); // 2, 같은 블록에 있으므로 c에 대한 정보를 가져올수 있습니다.
}

if (true) {
  // 블록 스코프
  const d = 3;
  console.log(d); // 3, 같은 블록에 있으므로 d에 접근이 가능합니다.
}

console.log(c); // ERROR!, 함수 스코프와 동일하게 함수 외부에서 함수 내부의 정보에 접근할수 없습니다.
console.log(d); // ERROR!, if문의 중괄호 블록 바깥에서 블록 내부에 있는 d에대해 접근이 불가합니다.
```

## 그럼 렉시컬 스코프는 뭐지?

렉시컬 스코프는 스코프의 위치를 정하는 방식인데요 변수나 함수가 호출되는곳에 따라서 스코프가 정해지는게 아닌 자신이 정의된곳에 따라 스코프가 결정되는 것을 말합니다.

이것 역시 말로만 해서는 무슨 뜻인지 잘 와닫지 않으니 예시 코드를 보여드리겠습니다.

```js
// 전역 스코프
var a = 1;

function b() {
  // 함수 b 스코프
  var a = 999;
  console.log(a); // 999, 가장 가까운 a인 같은 함수내에 있는 a의 값을 가져옵니다.
  c();
}

function c() {
  console.log(a);
  // 1, 함수 c를 함수 b에서 호출하였으므로 상위 스코프가 함수 b일것 같지만 함수 c를 정의했을때 이미 스코프가 결정되었으므로 상위 스코프는 함수 b의 스코프가 아닌 전역 스코프가 됩니다.
}

b();
```
